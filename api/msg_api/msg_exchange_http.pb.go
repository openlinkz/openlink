// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.6.1
// - protoc             v3.15.5
// source: api/msg_api/msg_exchange.proto

package msg_api

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationMsgExchangeServiceConnect = "/api.msg.api.MsgExchangeService/Connect"
const OperationMsgExchangeServiceDisconnect = "/api.msg.api.MsgExchangeService/Disconnect"
const OperationMsgExchangeServiceKeepAlive = "/api.msg.api.MsgExchangeService/KeepAlive"
const OperationMsgExchangeServiceSendMsg = "/api.msg.api.MsgExchangeService/SendMsg"

type MsgExchangeServiceHTTPServer interface {
	Connect(context.Context, *ConnectRequest) (*ConnectReply, error)
	Disconnect(context.Context, *DisconnectRequest) (*DisconnectReply, error)
	KeepAlive(context.Context, *KeepAliveRequest) (*KeepAliveReply, error)
	SendMsg(context.Context, *Msg) (*SendMsgReply, error)
}

func RegisterMsgExchangeServiceHTTPServer(s *http.Server, srv MsgExchangeServiceHTTPServer) {
	r := s.Route("/")
	r.POST("/exchange/send_message", _MsgExchangeService_SendMsg0_HTTP_Handler(srv))
	r.POST("/exchange/user_connect", _MsgExchangeService_Connect0_HTTP_Handler(srv))
	r.POST("/exchange/user_disconnect", _MsgExchangeService_Disconnect0_HTTP_Handler(srv))
	r.POST("/exchange/user_keepalive", _MsgExchangeService_KeepAlive0_HTTP_Handler(srv))
}

func _MsgExchangeService_SendMsg0_HTTP_Handler(srv MsgExchangeServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in Msg
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationMsgExchangeServiceSendMsg)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.SendMsg(ctx, req.(*Msg))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*SendMsgReply)
		return ctx.Result(200, reply)
	}
}

func _MsgExchangeService_Connect0_HTTP_Handler(srv MsgExchangeServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ConnectRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationMsgExchangeServiceConnect)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Connect(ctx, req.(*ConnectRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ConnectReply)
		return ctx.Result(200, reply)
	}
}

func _MsgExchangeService_Disconnect0_HTTP_Handler(srv MsgExchangeServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DisconnectRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationMsgExchangeServiceDisconnect)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.Disconnect(ctx, req.(*DisconnectRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DisconnectReply)
		return ctx.Result(200, reply)
	}
}

func _MsgExchangeService_KeepAlive0_HTTP_Handler(srv MsgExchangeServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in KeepAliveRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationMsgExchangeServiceKeepAlive)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.KeepAlive(ctx, req.(*KeepAliveRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*KeepAliveReply)
		return ctx.Result(200, reply)
	}
}

type MsgExchangeServiceHTTPClient interface {
	Connect(ctx context.Context, req *ConnectRequest, opts ...http.CallOption) (rsp *ConnectReply, err error)
	Disconnect(ctx context.Context, req *DisconnectRequest, opts ...http.CallOption) (rsp *DisconnectReply, err error)
	KeepAlive(ctx context.Context, req *KeepAliveRequest, opts ...http.CallOption) (rsp *KeepAliveReply, err error)
	SendMsg(ctx context.Context, req *Msg, opts ...http.CallOption) (rsp *SendMsgReply, err error)
}

type MsgExchangeServiceHTTPClientImpl struct {
	cc *http.Client
}

func NewMsgExchangeServiceHTTPClient(client *http.Client) MsgExchangeServiceHTTPClient {
	return &MsgExchangeServiceHTTPClientImpl{client}
}

func (c *MsgExchangeServiceHTTPClientImpl) Connect(ctx context.Context, in *ConnectRequest, opts ...http.CallOption) (*ConnectReply, error) {
	var out ConnectReply
	pattern := "/exchange/user_connect"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationMsgExchangeServiceConnect))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *MsgExchangeServiceHTTPClientImpl) Disconnect(ctx context.Context, in *DisconnectRequest, opts ...http.CallOption) (*DisconnectReply, error) {
	var out DisconnectReply
	pattern := "/exchange/user_disconnect"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationMsgExchangeServiceDisconnect))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *MsgExchangeServiceHTTPClientImpl) KeepAlive(ctx context.Context, in *KeepAliveRequest, opts ...http.CallOption) (*KeepAliveReply, error) {
	var out KeepAliveReply
	pattern := "/exchange/user_keepalive"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationMsgExchangeServiceKeepAlive))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *MsgExchangeServiceHTTPClientImpl) SendMsg(ctx context.Context, in *Msg, opts ...http.CallOption) (*SendMsgReply, error) {
	var out SendMsgReply
	pattern := "/exchange/send_message"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationMsgExchangeServiceSendMsg))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
